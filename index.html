<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pancake Stack Game</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Fredoka+One:wght@400&family=Fredoka:wght@300;400;500;600;700&display=swap");

      * {
        box-sizing: border-box;
      }

      body {
        font-family: "Fredoka", sans-serif;
        margin: 0;
        padding: 20px;
        background: linear-gradient(
          135deg,
          #ffe5b4 0%,
          #ffcc70 50%,
          #ffa500 100%
        );
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 20px;
        position: relative;
        overflow-x: auto;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="25" cy="25" r="2" fill="rgba(255,255,255,0.1)"/><circle cx="75" cy="75" r="1.5" fill="rgba(255,255,255,0.1)"/><circle cx="50" cy="10" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="10" cy="60" r="1.5" fill="rgba(255,255,255,0.1)"/><circle cx="90" cy="30" r="1" fill="rgba(255,255,255,0.1)"/></svg>')
          repeat;
        pointer-events: none;
        z-index: 1;
      }

      #topBar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(145deg, #ffffff, #f0f0f0);
        padding: 20px 30px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        z-index: 2;
        position: relative;
      }

      #topBar > div {
        display: flex;
        align-items: center;
        gap: 30px;
      }

      .top-stat {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 15px 25px;
        background: linear-gradient(145deg, #fafafa, #f5f5f5);
        border-radius: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        border: 2px solid transparent;
        transition: all 0.3s ease;
        min-width: 120px;
      }

      .top-stat:hover {
        border-color: #ffb347;
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
      }

      .top-stat h3 {
        margin: 0 0 10px 0;
        color: #333;
        font-size: 16px;
        font-weight: 600;
        font-family: "Fredoka One", cursive;
        text-align: center;
      }

      .top-stat-value {
        font-size: 24px;
        font-weight: bold;
        color: #444;
        text-align: center;
        font-family: "Fredoka One", cursive;
      }

      #gameContainer {
        display: flex;
        gap: 20px;
        z-index: 2;
        position: relative;
      }

      #gameGrid {
        width: 650px;
        height: 650px;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 8px;
        background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
        padding: 15px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      .cell {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-radius: 15px;
        font-size: 48px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        overflow: hidden;
      }

      .cell:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      }

      .cell.grill {
        background: linear-gradient(145deg, #d2691e, #8b4513);
        border: 3px solid #a0522d;
        position: relative;
      }

      .cell.grill::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
          45deg,
          transparent,
          transparent 10px,
          rgba(0, 0, 0, 0.1) 10px,
          rgba(0, 0, 0, 0.1) 20px
        );
        pointer-events: none;
      }

      .cell.grill:active {
        transform: scale(0.95);
      }

      .cell.plate {
        background: linear-gradient(145deg, #f8f8ff, #e6e6fa);
        border: 3px solid #d8bfd8;
        padding-bottom: 60px; /* Space for serve button */
      }

      .cell.drag-over {
        border-color: #00ff7f;
        border-width: 4px;
        box-shadow: 0 0 20px rgba(0, 255, 127, 0.5);
        animation: dragPulse 0.5s ease-in-out infinite alternate;
      }

      @keyframes dragPulse {
        from {
          transform: scale(1);
        }
        to {
          transform: scale(1.02);
        }
      }

      .progress-bar {
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        height: 12px;
        background: linear-gradient(90deg, #333, #555);
        border-radius: 6px;
        overflow: hidden;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff6b6b, #ff8e53);
        transition: width 0.1s ease;
        position: relative;
        border-radius: 6px;
        box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
      }

      .progress-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 50%;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        border-radius: 6px 6px 0 0;
      }

      .progress-marker {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 3px;
        background: linear-gradient(180deg, #fff, #e0e0e0);
        box-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
      }

      .progress-marker.done {
        left: 80%;
        background: linear-gradient(180deg, #00ff7f, #32cd32);
      }

      .progress-marker.burnt {
        left: 100%;
        background: linear-gradient(180deg, #ff4444, #cc0000);
      }

      .pancake {
        font-size: 48px;
        cursor: grab;
        margin: 2px;
        position: relative;
        z-index: 10;
        transition: transform 0.2s ease;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        pointer-events: auto;
        padding: 8px;
      }

      .pancake:hover {
        transform: scale(1.1);
      }

      .pancake:active {
        cursor: grabbing;
        transform: scale(0.95);
      }

      .pancake-stack {
        display: flex;
        flex-direction: column-reverse;
        align-items: center;
        position: absolute;
        bottom: 70px; /* Above serve button */
        left: 50%;
        transform: translateX(-50%);
      }

      .pancake-stack .pancake {
        margin: -8px 0;
        transition: transform 0.3s ease;
      }

      .pancake-stack .pancake:hover {
        transform: translateX(-50%) scale(1.1);
      }

      .stack-count {
        position: absolute;
        top: 10px;
        right: 10px;
        background: linear-gradient(145deg, #ff6b6b, #ff8e53);
        color: white;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        animation: bounce 2s infinite;
      }

      @keyframes bounce {
        0%,
        20%,
        50%,
        80%,
        100% {
          transform: translateY(0);
        }
        40% {
          transform: translateY(-5px);
        }
        60% {
          transform: translateY(-3px);
        }
      }

      .serve-button {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(145deg, #ff6b6b, #ff4444);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        font-family: "Fredoka", sans-serif;
        box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 20;
      }

      .serve-button:hover {
        transform: translateX(-50%) translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        background: linear-gradient(145deg, #ff8e53, #ff6b6b);
      }

      .serve-button:active {
        transform: translateX(-50%) translateY(0);
        box-shadow: 0 2px 10px rgba(255, 107, 107, 0.4);
      }

      .serve-button:disabled {
        background: linear-gradient(145deg, #ccc, #999);
        cursor: not-allowed;
        transform: translateX(-50%);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }

      #sidebar {
        width: 250px;
        background: linear-gradient(145deg, #ffffff, #f0f0f0);
        padding: 25px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        height: fit-content;
      }

      .sidebar-section {
        margin-bottom: 25px;
        padding: 20px;
        background: linear-gradient(145deg, #fafafa, #f5f5f5);
        border-radius: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        border: 2px solid transparent;
        transition: all 0.3s ease;
      }

      .sidebar-section:hover {
        border-color: #ffb347;
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
      }

      .sidebar-section h3 {
        margin: 0 0 15px 0;
        color: #333;
        font-size: 18px;
        font-weight: 600;
        font-family: "Fredoka One", cursive;
        text-align: center;
      }

      .store-section {
        border-color: #4caf50;
        background: linear-gradient(145deg, #f8fff8, #f0fff0);
      }

      .store-section h3 {
        color: #2e7d32;
      }

      .store-section.out-of-stock {
        animation: wiggleGlow 2s ease-in-out infinite;
        border-color: #ff6b6b;
        background: linear-gradient(145deg, #fff8f8, #fff0f0);
      }

      .store-section.out-of-stock h3 {
        color: #d32f2f;
      }

      @keyframes wiggleGlow {
        0%,
        100% {
          transform: rotate(0deg);
          box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        25% {
          transform: rotate(-2deg);
          box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        }
        75% {
          transform: rotate(2deg);
          box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        }
      }

      .resource-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
      }

      .resource-display {
        font-size: 16px;
        font-weight: 500;
        color: #444;
        text-align: center;
      }

      .buy-button {
        background: linear-gradient(145deg, #4caf50, #45a049);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        font-family: "Fredoka", sans-serif;
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        min-width: 120px;
      }

      .buy-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        background: linear-gradient(145deg, #5cbf60, #4caf50);
      }

      .buy-button:active {
        transform: translateY(0);
        box-shadow: 0 2px 10px rgba(76, 175, 80, 0.4);
      }

      .buy-button:disabled {
        background: linear-gradient(145deg, #ccc, #999);
        cursor: not-allowed;
        transform: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }

      .timer {
        font-size: 36px;
        font-weight: bold;
        color: #ff6b6b;
        text-align: center;
        font-family: "Fredoka One", cursive;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        animation: timerPulse 1s ease-in-out infinite alternate;
      }

      @keyframes timerPulse {
        from {
          transform: scale(1);
        }
        to {
          transform: scale(1.05);
        }
      }

      .timer.urgent {
        color: #ff4444;
        animation: urgentPulse 0.5s ease-in-out infinite alternate;
      }

      @keyframes urgentPulse {
        from {
          transform: scale(1);
          text-shadow: 2px 2px 4px rgba(255, 68, 68, 0.5);
        }
        to {
          transform: scale(1.1);
          text-shadow: 2px 2px 8px rgba(255, 68, 68, 0.8);
        }
      }

      .money-display {
        font-size: 28px;
        font-weight: bold;
        color: #4caf50;
        text-align: center;
        font-family: "Fredoka One", cursive;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
      }

      .current-order {
        font-size: 20px;
        font-weight: 600;
        color: #444;
        text-align: center;
        padding: 15px;
        background: linear-gradient(145deg, #ffe5b4, #ffcc70);
        border-radius: 15px;
        box-shadow: 0 4px 15px rgba(255, 204, 112, 0.3);
        animation: orderPulse 2s ease-in-out infinite alternate;
        font-family: "Fredoka One", cursive;
      }

      @keyframes orderPulse {
        from {
          box-shadow: 0 4px 15px rgba(255, 204, 112, 0.3);
        }
        to {
          box-shadow: 0 6px 20px rgba(255, 204, 112, 0.5);
        }
      }

      /* Screen shake effect */
      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        75% {
          transform: translateX(5px);
        }
      }

      .shake {
        animation: shake 0.5s ease-in-out;
      }

      /* Success glow effect */
      .success-glow {
        animation: successGlow 0.5s ease-in-out;
      }

      @keyframes successGlow {
        0% {
          box-shadow: 0 0 0 rgba(76, 175, 80, 0.7);
        }
        50% {
          box-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
        }
        100% {
          box-shadow: 0 0 0 rgba(76, 175, 80, 0.7);
        }
      }

      /* Dragged pancake visual */
      .dragged-pancake {
        position: fixed;
        font-size: 48px;
        pointer-events: none;
        z-index: 1001;
        filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
        animation: dragFloat 0.5s ease-in-out infinite alternate;
        transform-origin: center;
      }

      @keyframes dragFloat {
        from {
          transform: rotate(-2deg) scale(1.1);
        }
        to {
          transform: rotate(2deg) scale(1.2);
        }
      }

      /* Dragging states */
      .dragging {
        opacity: 0.5;
        transform: rotate(5deg) scale(0.9);
        z-index: 1000;
        pointer-events: none;
      }

      .cell.plate.drag-target {
        background: linear-gradient(145deg, #e6ffe6, #ccffcc);
        border-color: #4caf50;
      }

      /* Cooking pause visual indicator - only for specific pancake */
      .cooking-paused-specific .progress-fill {
        animation: pausedPulse 1s ease-in-out infinite alternate;
      }

      @keyframes pausedPulse {
        from {
          opacity: 0.7;
        }
        to {
          opacity: 1;
        }
      }

      /* Prevent text selection during drag */
      .cell {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      .cell * {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      .game-over-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        backdrop-filter: blur(5px);
      }

      .game-over-content {
        background: linear-gradient(145deg, #ffffff, #f0f0f0);
        padding: 50px;
        border-radius: 25px;
        text-align: center;
        max-width: 450px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        animation: gameOverAppear 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @keyframes gameOverAppear {
        from {
          opacity: 0;
          transform: scale(0.8) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      .game-over-content h2 {
        font-family: "Fredoka One", cursive;
        font-size: 32px;
        color: #333;
        margin-bottom: 20px;
      }

      .stars {
        font-size: 56px;
        margin: 30px 0;
        animation: starsSpin 2s ease-in-out infinite;
      }

      @keyframes starsSpin {
        0%,
        100% {
          transform: rotate(0deg);
        }
        50% {
          transform: rotate(5deg);
        }
      }

      .restart-button {
        background: linear-gradient(145deg, #4caf50, #45a049);
        color: white;
        border: none;
        padding: 20px 40px;
        border-radius: 30px;
        cursor: pointer;
        font-size: 18px;
        font-weight: 600;
        font-family: "Fredoka", sans-serif;
        box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        margin-top: 25px;
      }

      .restart-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(76, 175, 80, 0.6);
        background: linear-gradient(145deg, #5cbf60, #4caf50);
      }

      .restart-button:active {
        transform: translateY(-1px);
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
      }

      .hidden {
        display: none !important;
      }

      /* Score popup animations */
      .score-popup {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 24px;
        font-weight: bold;
        color: #4caf50;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        pointer-events: none;
        z-index: 100;
        animation: scorePopup 1s ease-out forwards;
      }

      @keyframes scorePopup {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.5);
        }
        50% {
          opacity: 1;
          transform: translate(-50%, -70%) scale(1.2);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -100%) scale(1);
        }
      }

      /* Particle effects */
      .particle {
        position: absolute;
        pointer-events: none;
        z-index: 50;
        animation: particle 1s ease-out forwards;
      }

      @keyframes particle {
        0% {
          opacity: 1;
          transform: scale(1) rotate(0deg);
        }
        100% {
          opacity: 0;
          transform: scale(0.5) rotate(360deg) translate(50px, -50px);
        }
      }
    </style>
  </head>
  <body>
    <div id="topBar">
      <div>
        <div class="top-stat">
          <h3>⏰ Time Left</h3>
          <div class="top-stat-value timer" id="timer">60</div>
        </div>

        <div class="top-stat">
          <h3>🎯 Current Order</h3>
          <div class="top-stat-value current-order" id="currentOrder">
            1 Pancake
          </div>
        </div>
      </div>

      <div>
        <div class="top-stat">
          <h3>💰 Earnings</h3>
          <div class="top-stat-value money-display" id="moneyDisplay">$0</div>
        </div>
      </div>
    </div>

    <div id="gameContainer">
      <div id="gameGrid"></div>
      <div id="sidebar">
        <div class="sidebar-section store-section" id="storeSection">
          <h3>🏪 Batter Store</h3>
          <div class="resource-item">
            <div class="resource-display">
              🥞 Batter: <span id="batterCount">10</span>
            </div>
            <button class="buy-button" id="buyBatter">Buy More ($1)</button>
          </div>
        </div>
      </div>
    </div>

    <div id="gameOverScreen" class="game-over-screen hidden">
      <div class="game-over-content">
        <h2>Level Complete!</h2>
        <div class="stars" id="starsDisplay">⭐⭐⭐</div>
        <div id="finalScore">Final Score: $0</div>
        <button class="restart-button" id="restartButton">Play Again</button>
      </div>
    </div>

    <script>
      class PancakeStackGame {
        constructor() {
          this.initializeGame();
          this.setupEventListeners();
          this.gameLoop();
        }

        initializeGame() {
          // Level 1 configuration
          this.levelConfig = {
            gridLayout: [
              "plate",
              "grill",
              "plate",
              "grill",
              "plate",
              "grill",
              "plate",
              "grill",
              "plate",
            ],
            cookingTime: 3000, // 3 seconds to 80%
            burntTime: 6000, // 6 seconds to 100%
            timeLimit: 60000, // 60 seconds
            orders: [1, 2, 1, 3], // sequence that repeats
            starThresholds: [3, 10, 30],
          };

          // Game state
          this.gameState = {
            timeRemaining: this.levelConfig.timeLimit,
            gameRunning: true,
            batter: 10,
            money: 0,
            currentOrderIndex: 0,
            totalOrdersCompleted: 0,
            isDragging: false,
            draggedPancakeId: null,
          };

          // Grid state
          this.grid = new Array(9).fill(null).map((_, index) => ({
            type: this.levelConfig.gridLayout[index],
            pancakes: [], // stack of pancakes
            cookingPancake: null, // pancake being cooked (for grills)
          }));

          // Pancake tracking
          this.pancakeIdCounter = 0;
          this.cookingPancakes = new Map(); // id -> pancake data

          this.createGrid();
          this.updateUI();
        }

        createGrid() {
          const gameGrid = document.getElementById("gameGrid");
          gameGrid.innerHTML = "";

          this.grid.forEach((cell, index) => {
            const cellDiv = document.createElement("div");
            cellDiv.className = `cell ${cell.type}`;
            cellDiv.dataset.cellIndex = index;

            if (cell.type === "grill") {
              cellDiv.innerHTML = "🔥";
              cellDiv.addEventListener("click", (e) => {
                this.addClickEffect(e);
                this.startCooking(index);
              });
            } else if (cell.type === "plate") {
              cellDiv.innerHTML = "🍽️";
              const serveButton = document.createElement("button");
              serveButton.className = "serve-button";
              serveButton.textContent = "Serve Order";
              serveButton.addEventListener("click", (e) => {
                e.stopPropagation();
                this.servePlate(index);
              });
              cellDiv.appendChild(serveButton);
            }

            // Add drop zone functionality for plates
            if (cell.type === "plate") {
              cellDiv.addEventListener(
                "dragover",
                this.handleDragOver.bind(this)
              );
              cellDiv.addEventListener("drop", this.handleDrop.bind(this));
              cellDiv.addEventListener(
                "dragenter",
                this.handleDragEnter.bind(this)
              );
              cellDiv.addEventListener(
                "dragleave",
                this.handleDragLeave.bind(this)
              );
            }

            gameGrid.appendChild(cellDiv);
          });
        }

        addClickEffect(e) {
          const ripple = document.createElement("div");
          ripple.style.cssText = `
                    position: absolute;
                    border-radius: 50%;
                    background: rgba(255,255,255,0.6);
                    transform: scale(0);
                    animation: ripple 0.6s linear;
                    pointer-events: none;
                `;

          const rect = e.currentTarget.getBoundingClientRect();
          const size = Math.max(rect.width, rect.height);
          ripple.style.width = ripple.style.height = size + "px";
          ripple.style.left = e.clientX - rect.left - size / 2 + "px";
          ripple.style.top = e.clientY - rect.top - size / 2 + "px";

          e.currentTarget.appendChild(ripple);

          setTimeout(() => ripple.remove(), 600);
        }

        startCooking(cellIndex) {
          if (!this.gameState.gameRunning) return;

          const cell = this.grid[cellIndex];
          if (cell.type !== "grill" || cell.cookingPancake) return;
          if (this.gameState.batter <= 0) return;

          // Consume batter
          this.gameState.batter--;

          // Create pancake
          const pancakeId = this.pancakeIdCounter++;
          const pancake = {
            id: pancakeId,
            type: "plain",
            progress: 0,
            startTime: Date.now(),
            cellIndex: cellIndex,
          };

          cell.cookingPancake = pancake;
          this.cookingPancakes.set(pancakeId, pancake);

          // Add sizzle effect
          this.addSizzleEffect(cellIndex);

          this.updateCellDisplay(cellIndex);
          this.updateUI();
        }

        addSizzleEffect(cellIndex) {
          const cellDiv = document.querySelector(
            `[data-cell-index="${cellIndex}"]`
          );
          cellDiv.classList.add("success-glow");
          setTimeout(() => cellDiv.classList.remove("success-glow"), 500);
        }

        updateCooking() {
          const currentTime = Date.now();

          this.cookingPancakes.forEach((pancake, id) => {
            // Check if this specific pancake is being dragged
            const isDraggedPancake =
              this.gameState.isDragging &&
              this.gameState.draggedPancakeId === id.toString();

            const cellDiv = document.querySelector(
              `[data-cell-index="${pancake.cellIndex}"]`
            );
            const progressBar = cellDiv?.querySelector(".progress-bar");

            if (isDraggedPancake) {
              // Pause only this pancake's cooking
              if (progressBar) {
                progressBar.classList.add("cooking-paused-specific");
              }

              // Store pause time if not already stored
              if (!pancake.pausedTime) {
                pancake.pausedTime = currentTime;
              }
              return; // Skip cooking progress for this pancake
            } else {
              // Remove paused indicator for this pancake
              if (progressBar) {
                progressBar.classList.remove("cooking-paused-specific");
              }

              // Resume cooking if it was paused
              if (pancake.pausedTime) {
                pancake.startTime += currentTime - pancake.pausedTime;
                delete pancake.pausedTime;
              }
            }

            // Continue normal cooking progress
            const elapsed = currentTime - pancake.startTime;
            pancake.progress = Math.min(
              100,
              (elapsed / this.levelConfig.burntTime) * 100
            );

            // Auto-remove burnt pancakes
            if (pancake.progress >= 100) {
              const cell = this.grid[pancake.cellIndex];
              cell.cookingPancake = null;
              this.cookingPancakes.delete(id);
              this.updateCellDisplay(pancake.cellIndex);
              this.addBurntEffect(pancake.cellIndex);
              return;
            }

            this.updateCellDisplay(pancake.cellIndex);
          });
        }

        addBurntEffect(cellIndex) {
          const cellDiv = document.querySelector(
            `[data-cell-index="${cellIndex}"]`
          );
          const particles = ["💨", "🔥", "💨"];

          particles.forEach((particle, i) => {
            setTimeout(() => {
              const particleEl = document.createElement("div");
              particleEl.className = "particle";
              particleEl.textContent = particle;
              particleEl.style.left = Math.random() * 100 + "%";
              particleEl.style.top = Math.random() * 100 + "%";
              cellDiv.appendChild(particleEl);

              setTimeout(() => particleEl.remove(), 1000);
            }, i * 100);
          });
        }

        updateCellDisplay(cellIndex) {
          const cell = this.grid[cellIndex];
          const cellDiv = document.querySelector(
            `[data-cell-index="${cellIndex}"]`
          );

          if (cell.type === "grill" && cell.cookingPancake) {
            const pancake = cell.cookingPancake;
            const progress = pancake.progress;

            // Update progress bar
            let progressBar = cellDiv.querySelector(".progress-bar");
            if (!progressBar) {
              progressBar = document.createElement("div");
              progressBar.className = "progress-bar";
              progressBar.innerHTML = `
                            <div class="progress-fill"></div>
                            <div class="progress-marker done"></div>
                        `;
              cellDiv.appendChild(progressBar);
            }

            const progressFill = progressBar.querySelector(".progress-fill");
            progressFill.style.width = `${progress}%`;

            // Show pancake immediately when batter is placed
            let pancakeEmoji = cellDiv.querySelector(".pancake");
            if (!pancakeEmoji) {
              pancakeEmoji = document.createElement("div");
              pancakeEmoji.className = "pancake";
              pancakeEmoji.dataset.pancakeId = pancake.id;
              cellDiv.appendChild(pancakeEmoji);
            }

            // Update pancake appearance based on progress
            if (progress < 80) {
              pancakeEmoji.innerHTML = "🍞"; // Uncooked bread
              pancakeEmoji.draggable = false;
              pancakeEmoji.style.cursor = "not-allowed";
            } else {
              pancakeEmoji.innerHTML = "🥞"; // Cooked pancake
              pancakeEmoji.draggable = false; // Disable HTML5 drag
              pancakeEmoji.style.cursor = "grab";

              // Remove any existing event listeners
              pancakeEmoji.removeEventListener(
                "mousedown",
                this.handleMouseDown
              );
              pancakeEmoji.removeEventListener(
                "dragstart",
                this.handleDragStart
              );

              // Add mouse-based drag handling
              pancakeEmoji.addEventListener(
                "mousedown",
                this.handleMouseDown.bind(this)
              );
              pancakeEmoji.addEventListener("dragstart", (e) =>
                e.preventDefault()
              );
            }
          } else if (cell.type === "grill") {
            // Clear grill display when no pancake
            const progressBar = cellDiv.querySelector(".progress-bar");
            const pancakeEmoji = cellDiv.querySelector(".pancake");
            if (progressBar) progressBar.remove();
            if (pancakeEmoji) pancakeEmoji.remove();
          } else if (cell.type === "plate") {
            // Update plate display with stacked pancakes
            const existingStack = cellDiv.querySelector(".pancake-stack");
            const existingCount = cellDiv.querySelector(".stack-count");
            if (existingStack) existingStack.remove();
            if (existingCount) existingCount.remove();

            if (cell.pancakes.length > 0) {
              // Add stack count
              const countDiv = document.createElement("div");
              countDiv.className = "stack-count";
              countDiv.textContent = cell.pancakes.length;
              cellDiv.appendChild(countDiv);

              const stackDiv = document.createElement("div");
              stackDiv.className = "pancake-stack";

              cell.pancakes.forEach((pancake, index) => {
                const pancakeDiv = document.createElement("div");
                pancakeDiv.className = "pancake";
                pancakeDiv.innerHTML = "🥞";
                pancakeDiv.dataset.pancakeId = pancake.id;

                // Only top pancake is draggable
                if (index === cell.pancakes.length - 1) {
                  pancakeDiv.draggable = false; // Disable HTML5 drag

                  // Remove any existing event listeners
                  pancakeDiv.removeEventListener(
                    "mousedown",
                    this.handleMouseDown
                  );
                  pancakeDiv.removeEventListener(
                    "dragstart",
                    this.handleDragStart
                  );

                  // Add mouse-based drag handling
                  pancakeDiv.addEventListener(
                    "mousedown",
                    this.handleMouseDown.bind(this)
                  );
                  pancakeDiv.addEventListener("dragstart", (e) =>
                    e.preventDefault()
                  );
                }

                stackDiv.appendChild(pancakeDiv);
              });

              cellDiv.appendChild(stackDiv);
            }
          }
        }

        handleMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();

          const pancakeId = e.target.dataset.pancakeId;
          if (!pancakeId) return;

          // Set dragging state
          this.gameState.isDragging = true;
          this.gameState.draggedPancakeId = pancakeId;

          // Add visual feedback to original pancake
          e.target.classList.add("dragging");
          e.target.style.cursor = "grabbing";

          // Create dragged pancake visual
          const draggedPancake = document.createElement("div");
          draggedPancake.className = "dragged-pancake";
          draggedPancake.textContent = "🥞";
          draggedPancake.id = "draggedPancakeVisual";
          document.body.appendChild(draggedPancake);

          // Add drag effect to valid drop zones
          document.querySelectorAll(".cell.plate").forEach((plate) => {
            plate.classList.add("drag-target");
          });

          // Add mouse move and up listeners
          const handleMouseMove = (moveEvent) => {
            // Update dragged pancake position
            const draggedElement = document.getElementById(
              "draggedPancakeVisual"
            );
            if (draggedElement) {
              draggedElement.style.left = moveEvent.clientX - 24 + "px";
              draggedElement.style.top = moveEvent.clientY - 24 + "px";
            }
          };

          const handleMouseUp = (upEvent) => {
            // Reset dragging state
            this.gameState.isDragging = false;

            // Remove dragged pancake visual
            const draggedElement = document.getElementById(
              "draggedPancakeVisual"
            );
            if (draggedElement) {
              draggedElement.remove();
            }

            // Clean up drag effects
            document
              .querySelectorAll(".pancake.dragging")
              .forEach((pancake) => {
                pancake.classList.remove("dragging");
                pancake.style.cursor = "grab";
              });
            document
              .querySelectorAll(".cell.plate.drag-target")
              .forEach((plate) => {
                plate.classList.remove("drag-target");
              });
            document
              .querySelectorAll(".cell.plate.drag-over")
              .forEach((plate) => {
                plate.classList.remove("drag-over");
              });

            // Clean up any remaining paused indicators
            document
              .querySelectorAll(".progress-bar.cooking-paused-specific")
              .forEach((bar) => {
                bar.classList.remove("cooking-paused-specific");
              });

            // Find the drop target
            const elementUnderMouse = document.elementFromPoint(
              upEvent.clientX,
              upEvent.clientY
            );
            const plateCell = elementUnderMouse?.closest(".cell.plate");

            if (plateCell && this.gameState.draggedPancakeId) {
              const targetCellIndex = parseInt(plateCell.dataset.cellIndex);
              this.movePancake(
                parseInt(this.gameState.draggedPancakeId),
                targetCellIndex
              );
            }

            this.gameState.draggedPancakeId = null;

            // Remove event listeners
            document.removeEventListener("mousemove", handleMouseMove);
            document.removeEventListener("mouseup", handleMouseUp);
          };

          // Set initial position of dragged pancake
          const rect = e.target.getBoundingClientRect();
          const draggedElement = document.getElementById(
            "draggedPancakeVisual"
          );
          if (draggedElement) {
            draggedElement.style.left = rect.left + rect.width / 2 - 24 + "px";
            draggedElement.style.top = rect.top + rect.height / 2 - 24 + "px";
          }

          // Add event listeners
          document.addEventListener("mousemove", handleMouseMove);
          document.addEventListener("mouseup", handleMouseUp);

          // Add hover effects for drop targets
          document.querySelectorAll(".cell.plate").forEach((plate) => {
            const handleMouseEnter = () => plate.classList.add("drag-over");
            const handleMouseLeave = () => plate.classList.remove("drag-over");

            plate.addEventListener("mouseenter", handleMouseEnter);
            plate.addEventListener("mouseleave", handleMouseLeave);

            // Clean up these listeners when drag ends
            document.addEventListener(
              "mouseup",
              () => {
                plate.removeEventListener("mouseenter", handleMouseEnter);
                plate.removeEventListener("mouseleave", handleMouseLeave);
              },
              { once: true }
            );
          });
        }

        handleDragStart(e) {
          e.preventDefault();
          return false;
        }

        handleDragOver(e) {
          e.preventDefault();
          return false;
        }

        handleDragEnter(e) {
          e.preventDefault();
          e.currentTarget.classList.add("drag-over");
        }

        handleDragLeave(e) {
          e.currentTarget.classList.remove("drag-over");
        }

        handleDrop(e) {
          e.preventDefault();
          e.currentTarget.classList.remove("drag-over");
          return false;
        }

        movePancake(pancakeId, targetCellIndex) {
          const targetCell = this.grid[targetCellIndex];
          if (targetCell.type !== "plate") return;

          // Find source of pancake
          let sourcePancake = null;
          let sourceCell = null;
          let sourceIndex = -1;

          // Check if it's a cooking pancake
          if (this.cookingPancakes.has(pancakeId)) {
            sourcePancake = this.cookingPancakes.get(pancakeId);
            if (sourcePancake.progress < 80) {
              // Discard unfinished pancake
              sourceCell = this.grid[sourcePancake.cellIndex];
              sourceCell.cookingPancake = null;
              this.cookingPancakes.delete(pancakeId);
              this.updateCellDisplay(sourcePancake.cellIndex);
              return;
            }

            // Move finished pancake from grill to plate
            sourceCell = this.grid[sourcePancake.cellIndex];
            sourceCell.cookingPancake = null;
            this.cookingPancakes.delete(pancakeId);

            // Add to target plate
            targetCell.pancakes.push({
              id: pancakeId,
              type: "plain",
            });

            // Add move effect
            this.addMoveEffect(targetCellIndex);

            this.updateCellDisplay(sourcePancake.cellIndex);
            this.updateCellDisplay(targetCellIndex);
            return;
          }

          // Check if it's on a plate (top pancake only)
          for (let i = 0; i < this.grid.length; i++) {
            const cell = this.grid[i];
            if (cell.type === "plate" && cell.pancakes.length > 0) {
              const topPancake = cell.pancakes[cell.pancakes.length - 1];
              if (topPancake.id === pancakeId) {
                // Remove from source plate
                cell.pancakes.pop();

                // Add to target plate
                targetCell.pancakes.push(topPancake);

                // Add move effect
                this.addMoveEffect(targetCellIndex);

                this.updateCellDisplay(i);
                this.updateCellDisplay(targetCellIndex);
                return;
              }
            }
          }
        }

        addMoveEffect(cellIndex) {
          const cellDiv = document.querySelector(
            `[data-cell-index="${cellIndex}"]`
          );
          const particles = ["✨", "⭐", "✨"];

          particles.forEach((particle, i) => {
            setTimeout(() => {
              const particleEl = document.createElement("div");
              particleEl.className = "particle";
              particleEl.textContent = particle;
              particleEl.style.left = Math.random() * 100 + "%";
              particleEl.style.top = Math.random() * 100 + "%";
              cellDiv.appendChild(particleEl);

              setTimeout(() => particleEl.remove(), 1000);
            }, i * 100);
          });
        }

        servePlate(cellIndex) {
          if (!this.gameState.gameRunning) return;

          const cell = this.grid[cellIndex];
          if (cell.type !== "plate" || cell.pancakes.length === 0) return;

          const currentOrder = this.getCurrentOrder();
          const servedPancakes = cell.pancakes.length;

          // Calculate payment
          let payment = 0;
          const correctPancakes = Math.min(servedPancakes, currentOrder);
          payment += correctPancakes * 1; // $1 per correct pancake

          // Penalty for extra pancakes
          if (servedPancakes > currentOrder) {
            payment -= (servedPancakes - currentOrder) * 1;
          }

          // Ensure payment is not negative
          payment = Math.max(0, payment);

          this.gameState.money += payment;

          // Add success effects
          this.addSuccessEffect(cellIndex, payment);
          this.screenShake();

          // Clear the plate
          cell.pancakes = [];
          this.updateCellDisplay(cellIndex);

          // Move to next order
          this.gameState.currentOrderIndex =
            (this.gameState.currentOrderIndex + 1) %
            this.levelConfig.orders.length;
          this.gameState.totalOrdersCompleted++;

          this.updateUI();
        }

        addSuccessEffect(cellIndex, payment) {
          const cellDiv = document.querySelector(
            `[data-cell-index="${cellIndex}"]`
          );

          // Score popup
          const scorePopup = document.createElement("div");
          scorePopup.className = "score-popup";
          scorePopup.textContent = `+$${payment}`;
          cellDiv.appendChild(scorePopup);

          setTimeout(() => scorePopup.remove(), 1000);

          // Confetti particles
          const confetti = ["🎉", "🎊", "✨", "⭐", "🌟"];
          for (let i = 0; i < 8; i++) {
            setTimeout(() => {
              const particleEl = document.createElement("div");
              particleEl.className = "particle";
              particleEl.textContent =
                confetti[Math.floor(Math.random() * confetti.length)];
              particleEl.style.left = Math.random() * 100 + "%";
              particleEl.style.top = Math.random() * 100 + "%";
              cellDiv.appendChild(particleEl);

              setTimeout(() => particleEl.remove(), 1000);
            }, i * 50);
          }

          // Glow effect
          cellDiv.classList.add("success-glow");
          setTimeout(() => cellDiv.classList.remove("success-glow"), 500);
        }

        screenShake() {
          document.body.classList.add("shake");
          setTimeout(() => document.body.classList.remove("shake"), 500);
        }

        getCurrentOrder() {
          return this.levelConfig.orders[this.gameState.currentOrderIndex];
        }

        buyBatter() {
          if (!this.gameState.gameRunning) return;

          this.gameState.money -= 1;
          this.gameState.batter += 10;

          // Add purchase effect
          const buyButton = document.getElementById("buyBatter");
          buyButton.classList.add("success-glow");
          setTimeout(() => buyButton.classList.remove("success-glow"), 500);

          this.updateUI();
        }

        updateUI() {
          const timeSeconds = Math.ceil(this.gameState.timeRemaining / 1000);
          const timerEl = document.getElementById("timer");
          timerEl.textContent = timeSeconds;

          // Add urgent styling when time is low
          if (timeSeconds <= 10) {
            timerEl.classList.add("urgent");
          } else {
            timerEl.classList.remove("urgent");
          }

          document.getElementById(
            "currentOrder"
          ).textContent = `${this.getCurrentOrder()} Pancake${
            this.getCurrentOrder() > 1 ? "s" : ""
          }`;
          document.getElementById("batterCount").textContent =
            this.gameState.batter;
          document.getElementById(
            "moneyDisplay"
          ).textContent = `${this.gameState.money}`;

          // Update store section styling based on batter count
          const storeSection = document.getElementById("storeSection");
          const buyButton = document.getElementById("buyBatter");

          if (this.gameState.batter === 0) {
            storeSection.classList.add("out-of-stock");
          } else {
            storeSection.classList.remove("out-of-stock");
          }

          // Update buy button (allow going into debt)
          buyButton.disabled = false;
        }

        gameLoop() {
          if (!this.gameState.gameRunning) return;

          this.updateCooking();
          this.gameState.timeRemaining -= 100;

          if (this.gameState.timeRemaining <= 0) {
            this.endGame();
            return;
          }

          this.updateUI();

          setTimeout(() => this.gameLoop(), 100);
        }

        endGame() {
          this.gameState.gameRunning = false;

          // Calculate stars
          const finalScore = this.gameState.money;
          let stars = 0;

          if (finalScore >= this.levelConfig.starThresholds[2]) stars = 3;
          else if (finalScore >= this.levelConfig.starThresholds[1]) stars = 2;
          else if (finalScore >= this.levelConfig.starThresholds[0]) stars = 1;

          // Show game over screen
          const gameOverScreen = document.getElementById("gameOverScreen");
          const starsDisplay = document.getElementById("starsDisplay");
          const finalScoreDisplay = document.getElementById("finalScore");

          starsDisplay.textContent = "⭐".repeat(stars) + "☆".repeat(3 - stars);
          finalScoreDisplay.textContent = `Final Score: $${finalScore}`;

          gameOverScreen.classList.remove("hidden");
        }

        restart() {
          document.getElementById("gameOverScreen").classList.add("hidden");
          this.initializeGame();
        }

        setupEventListeners() {
          document
            .getElementById("buyBatter")
            .addEventListener("click", () => this.buyBatter());
          document
            .getElementById("restartButton")
            .addEventListener("click", () => this.restart());

          // Add CSS animations for ripple effect
          const style = document.createElement("style");
          style.textContent = `
                    @keyframes ripple {
                        to {
                            transform: scale(4);
                            opacity: 0;
                        }
                    }
                `;
          document.head.appendChild(style);
        }
      }

      // Start the game
      const game = new PancakeStackGame();
    </script>
  </body>
</html>
